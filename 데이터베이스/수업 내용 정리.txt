- 지난시간: 용어 정리, 응용 분야
- 이번시간: 특징, 파일시스템의 역할과 문제점, 관리시스템의 기능

사용예: 항공기 예약 시스템, 학생 정보, 백신예약 시스템 등
화일시스템: 데이터에 대한 프로그램의 의존도가 높다.
데이터베이스: 데이터의 중복을 없애는것이 가장 중요
읽기만 가능 -> 동시성제어

2주차 -2

메타데이터 - 데이터의 구조가 바껴도 메타데이터에 데이터가 반영. 프로그램과 데이터가 분리됨.
데이터에 대한 다양한 뷰: 누가 보냐에 따라 데이터를 다르게 보여줌.(예> 관리자: 모두, 학생: 일부)
스키마와 상태: 	스키마- 데이터베이스의 구조. 자주 변경되지 않음 / 상태- 내용. 계속 바뀜 
		(예> 학번, 번호->스키마, 2018182021, 21번->상태)
DBMS의 효과
DBMS는 비쌈 

3주차
화일: 여러 레코드가 순차적으로 저장되어 있는 것. 
레코드: 여러 개의 필드로 구성되어 있다.
레코드의 특징
1. 필드의 개수, 데이터 타입은 동일
2. 각 필드의 크기는 고정
3. 모든 레코드의 크기는 동일


배열: 공간고정, 연속공간 사용
연결리스트: 중간 데이터 찾을때 헤드부터 찾아야함.HDD 엑세스 과도해짐.이진검색을 사용못함
순서화일: 특정 필드 값의 크기 순서대로 레코드를 저장한 화일
이진검색: 정렬,임의의 데이터엑세스 가능
순서화일: 순차검색을 해야함

4주차 - 3차시 인덱스-삽입3
안	디스크엑세스 횟수
1	5
2	5 -> 가운데에 넣으면 4회
3	5
4	4 -> 제일 좋은 안일까?
삽입 알고리즘은 레코드가 꽉꽉 채워져있다고 생각하고 넣는데 빈공간이 있다면 수정된 알고리즘필요

4주차 - 4 순서화일의 연속삽입

1. 위 방식을 사용하면 빈자리가 너무 많아져 저장공간 낭비
2. 성능 저하 - 블록의 개수 증가

삽입 다시
1. 삽입할 자리를 찾는다.
2. 찾은 블록A에 공간이 있으면 삽입하고 종료
3. A에 공간이 없으면
   3-1. 새로운 블록(B)을 할당하여 A뒤에 연결
   3-2. A에 저장되어 있던 레코드와 삽입할 레코드를 A와 B에 절반씩 나누어 저장하고 종료
이 알고리즘 사용시 검색 알고리즘 수정해야함

문제점?: 	그래도 빈공간이 있지않나? -> 모든 블럭이 절반이상 차있으므로 훨씬 효율적
	블럭의 개수를 줄이는 것이 속도향상에 영향

과제: 순서화일에서의 삭제 빈공간 처리


5주 1차시 - 순서화일에서의 삭제

삭제 알고리즘
1. 삭제할 레코드를 찾는다.
2. 삭제한다.
3. 삭제한 빈 공간을 처리한다 -> 어떻게 처리?

빈 공간 처리
A. 그냥 둔다. 즉, 처리하지 않는다. x
B. A내 레코드 개수가 0이 되면 블록을 삭제한다. x
C. A내 레코드 개수가 X가 되면 앞뒤블록과 합친다. x-> 하나의 블록에 넣고 빈블록 삭제 
	->문제점: X개는 몇개로해야하며 앞뒤블록 몇개랑 합쳐야함? 이걸 어케 찾음?
	해결: 블록사용률a 50% 이하가 되면
	3-1. 다음 블록b를 읽어 블록사용률b를 계산
	3-2. a+b <= 100%면 합친다.
	3-3. a+b > 100%이면 B에서 A로 일부 레코드를 이동하여 A,B모두 50%이상이 되도록한다.
	=> 전체 블록의 개수 맥시멈 1/2

Q. 저장공간 사용량의 관점에서?: 2배이하. 최소 절반은 채워져있으니
Q. 하드디스크 엑세스 횟수의 관점에서?O(N) -> 블록의 개수가 미니멈일때. 최대2배.(2N)
5주-2차시

<인덱스>
- 레코드를 빠르게 찾을 수 있도록 도와주는 보조 화일
- 화일을 읽는 또다른 방법
- 인덱스에서 레코드를 찾아가는 방법
	: 인덱스에서 원하는 레코드를 찾기(순차검색) 
	  ->인덱스에서 찾은 위치로 가서 그 블록을 순차검색해서 찾음
- 인덱스의 레코드: 엔트리
- 인덱스를 사용하면 하드웨어 엑세스가 줄어들까?
   : 저장공간에서는 손해. 엔트리를 저장할 공간을 만들어야하므로
   : 3을 찾을때-> 각각 3번으로 동일하지만, 1의 경우-> 인덱스 사용하면 손해.
     그러나 숫자가 클수록 인덱스를 사용하는게 효율적. 데이터가 크면클수록 인덱스가 효율

   