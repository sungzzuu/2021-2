- 지난시간: 용어 정리, 응용 분야
- 이번시간: 특징, 파일시스템의 역할과 문제점, 관리시스템의 기능

사용예: 항공기 예약 시스템, 학생 정보, 백신예약 시스템 등
화일시스템: 데이터에 대한 프로그램의 의존도가 높다.
데이터베이스: 데이터의 중복을 없애는것이 가장 중요
읽기만 가능 -> 동시성제어

2주차 -2

메타데이터 - 데이터의 구조가 바껴도 메타데이터에 데이터가 반영. 프로그램과 데이터가 분리됨.
데이터에 대한 다양한 뷰: 누가 보냐에 따라 데이터를 다르게 보여줌.(예> 관리자: 모두, 학생: 일부)
스키마와 상태: 	스키마- 데이터베이스의 구조. 자주 변경되지 않음 / 상태- 내용. 계속 바뀜 
		(예> 학번, 번호->스키마, 2018182021, 21번->상태)
DBMS의 효과
DBMS는 비쌈 

3주차
화일: 여러 레코드가 순차적으로 저장되어 있는 것. 
레코드: 여러 개의 필드로 구성되어 있다.
레코드의 특징
1. 필드의 개수, 데이터 타입은 동일
2. 각 필드의 크기는 고정
3. 모든 레코드의 크기는 동일


배열: 공간고정, 연속공간 사용
연결리스트: 중간 데이터 찾을때 헤드부터 찾아야함.HDD 엑세스 과도해짐.이진검색을 사용못함
순서화일: 특정 필드 값의 크기 순서대로 레코드를 저장한 화일
이진검색: 정렬,임의의 데이터엑세스 가능
순서화일: 순차검색을 해야함

4주차 - 3차시 인덱스-삽입3
안	디스크엑세스 횟수
1	5
2	5 -> 가운데에 넣으면 4회
3	5
4	4 -> 제일 좋은 안일까?
삽입 알고리즘은 레코드가 꽉꽉 채워져있다고 생각하고 넣는데 빈공간이 있다면 수정된 알고리즘필요

4주차 - 4 순서화일의 연속삽입

1. 위 방식을 사용하면 빈자리가 너무 많아져 저장공간 낭비
2. 성능 저하 - 블록의 개수 증가

삽입 다시
1. 삽입할 자리를 찾는다.
2. 찾은 블록A에 공간이 있으면 삽입하고 종료
3. A에 공간이 없으면
   3-1. 새로운 블록(B)을 할당하여 A뒤에 연결
   3-2. A에 저장되어 있던 레코드와 삽입할 레코드를 A와 B에 절반씩 나누어 저장하고 종료
이 알고리즘 사용시 검색 알고리즘 수정해야함

문제점?: 	그래도 빈공간이 있지않나? -> 모든 블럭이 절반이상 차있으므로 훨씬 효율적
	블럭의 개수를 줄이는 것이 속도향상에 영향

과제: 순서화일에서의 삭제 빈공간 처리


5주 1차시 - 순서화일에서의 삭제

삭제 알고리즘
1. 삭제할 레코드를 찾는다.
2. 삭제한다.
3. 삭제한 빈 공간을 처리한다 -> 어떻게 처리?

빈 공간 처리
A. 그냥 둔다. 즉, 처리하지 않는다. x
B. A내 레코드 개수가 0이 되면 블록을 삭제한다. x
C. A내 레코드 개수가 X가 되면 앞뒤블록과 합친다. x-> 하나의 블록에 넣고 빈블록 삭제 
	->문제점: X개는 몇개로해야하며 앞뒤블록 몇개랑 합쳐야함? 이걸 어케 찾음?
	해결: 블록사용률a 50% 이하가 되면
	3-1. 다음 블록b를 읽어 블록사용률b를 계산
	3-2. a+b <= 100%면 합친다.
	3-3. a+b > 100%이면 B에서 A로 일부 레코드를 이동하여 A,B모두 50%이상이 되도록한다.
	=> 전체 블록의 개수 맥시멈 1/2

Q. 저장공간 사용량의 관점에서?: 2배이하. 최소 절반은 채워져있으니
Q. 하드디스크 엑세스 횟수의 관점에서?O(N) -> 블록의 개수가 미니멈일때. 최대2배.(2N)

5주 - 2차시

<인덱스>
- 레코드를 빠르게 찾을 수 있도록 도와주는 보조 화일
- 화일을 읽는 또다른 방법
- 인덱스에서 레코드를 찾아가는 방법
	: 인덱스에서 원하는 레코드를 찾기(순차검색) 
	  ->인덱스에서 찾은 위치로 가서 그 블록을 순차검색해서 찾음
- 인덱스의 레코드: 엔트리
- 인덱스를 사용하면 하드웨어 엑세스가 줄어들까?
   : 저장공간에서는 손해. 엔트리를 저장할 공간을 만들어야하므로
   : 3을 찾을때-> 각각 3번으로 동일하지만, 1의 경우-> 인덱스 사용하면 손해.
     그러나 숫자가 클수록 인덱스를 사용하는게 효율적. 데이터가 크면클수록 인덱스가 효율


5주 - 3차시

- key값에 해당하는 필드는 여러개 일 수 있음. 

삽입 알고리즘
1. 삽입될 자리를 찾는다.
2. 공간이 없으면 공간을 만든다.
3. 삽입한다.
4. 필요하면 인덱스에 반영한다: 인덱스에서의 분할 -> 추가적인 디스크 엑세스 발생
	-> 새로운 키값 추가시 인덱스 파일의 공간이 모자르면 새로 하나 만듬
	-> 포인터 변경

삭제 알고리즘
1. 삭제할 레코드를 찾는다.
2. 삭제한다.
3. 필요하면 삭제한 공간을 처리한다.
4. 필요하면 인덱스에 반영한다: 인덱스에서의 병합/재분배
	-> key값이 4인 레코드가 존재하지 않게되면 인덱스 파일에서도 삭제가 일어난다.
	-> 인덱스 파일에서의 삭제는 데이터 파일에서의 삭제와 동일

Q. 인덱스를 삭제하거나 삽입하면 인덱스에서의 디스크 엑세스 횟수가 늘어날텐데 좋을까?
A. 검색의 비율이 매우크므로 인덱스를 사용하는 것이 효율적이다.

내용정리
- 데이터 파일의 구조 만든기. 순서화일
- 인덱스 구조
- 삽입, 삭제만을 보면 성능에 손해지만 검색에서는 더 빨라 성능이 더 좋다.

5주 - 4차시 기본 인덱스 - 중복없는 데이터

<알파벳순서대로 할경우 문제점>
1. 불필요한 인덱스 엔트리
2. 데이터 파일에서의 블록 엑세스 증가
	-> 데이터파일의 효율 증가를 위해서는 인덱스 효율 감소
=> 순서 필드 값의 분포 불균형 때문
=> 전체 키 범위가 균등하게 분할된 것이 문제 
=> 인덱스 엔트리가 표현하는 범위에 블록이 하나씩만 들어가도록 분할할 수 있을까?

Q. 인덱스 엔트리에서 키 필드의 의미?
A. 특정 값이 아니라 값의 범위

C. 순서화일에 중복이 없을때 블록의 첫번째값을 키값으로 사용하는 기본 인덱스를 사용한다.

과제: 기본 인덱스의 검색알고리즘 정리 & 삭제, 삽입 알고리즘


6주-1

삽입 알고리즘
1. 삽입될 자리를 찾는다.
2. 공간이 없으면 공간을 만든다.
3. 삽입한다.
4. 필요하면 인덱스에 반영


삭제 알고리즘
1. 삭제할 레코드를 찾는다.
2. 삭제한다.
3. 필요하면 삭제한 공간을 처리한다.
4. 필요하면 인덱스에 반영한다.
Q. 언제 인덱스에 반영하는가?
A.
1. 병합이 일어났을 때
2. 재분배가 일어났을 때
3. 블록의 첫번째 레코드가 삭제되었을 때 -> 그냥 삭제만 해도됨


인덱스의 종류
밀집 인덱스 vs 희소 인덱스(기본인덱스)
밀집 인덱스: 데이터 화일내의 모든 탐색 키 값(즉, 모든 레코드)에 대한 인덱스 엔트리를 정의
희소 인덱스: 탐색 값의 일부에 대해서만 인덱스 엔트리를 정의
















